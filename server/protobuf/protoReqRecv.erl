%% -*- coding: utf-8 -*-
%% Automatically generated, do not edit
%% Generated by gpb_compile version 4.1.1
-module(protoReqRecv).

-export([encode_msg/1, encode_msg/2]).
-export([decode_msg/2, decode_msg/3]).
-export([merge_msgs/2, merge_msgs/3]).
-export([verify_msg/1, verify_msg/2]).
-export([get_msg_defs/0]).
-export([get_msg_names/0]).
-export([get_group_names/0]).
-export([get_msg_or_group_names/0]).
-export([get_enum_names/0]).
-export([find_msg_def/1, fetch_msg_def/1]).
-export([find_enum_def/1, fetch_enum_def/1]).
-export([enum_symbol_by_value/2, enum_value_by_symbol/2]).
-export([get_service_names/0]).
-export([get_service_def/1]).
-export([get_rpc_names/1]).
-export([find_rpc_def/2, fetch_rpc_def/2]).
-export([get_package_name/0]).
-export([gpb_version_as_string/0, gpb_version_as_list/0]).

-include("protoReqRecv.hrl").
-include("gpb.hrl").

%% enumerated types

-export_type([]).

%% message types
-type 'Sell'() :: #'Sell'{}.
-type 'UpdateReply'() :: #'UpdateReply'{}.
-type 'ResponseAfterRecv'() :: #'ResponseAfterRecv'{}.
-type 'Reply'() :: #'Reply'{}.
-type 'Buy'() :: #'Buy'{}.
-type 'General'() :: #'General'{}.
-export_type(['Sell'/0, 'UpdateReply'/0, 'ResponseAfterRecv'/0, 'Reply'/0, 'Buy'/0, 'General'/0]).

-spec encode_msg(#'Sell'{} | #'UpdateReply'{} | #'ResponseAfterRecv'{} | #'Reply'{} | #'Buy'{} | #'General'{}) -> binary().
encode_msg(Msg) -> encode_msg(Msg, []).


-spec encode_msg(#'Sell'{} | #'UpdateReply'{} | #'ResponseAfterRecv'{} | #'Reply'{} | #'Buy'{} | #'General'{}, list()) -> binary().
encode_msg(Msg, Opts) ->
    case proplists:get_bool(verify, Opts) of
      true -> verify_msg(Msg, Opts);
      false -> ok
    end,
    TrUserData = proplists:get_value(user_data, Opts),
    case Msg of
      #'Sell'{} -> e_msg_Sell(Msg, TrUserData);
      #'UpdateReply'{} -> e_msg_UpdateReply(Msg, TrUserData);
      #'ResponseAfterRecv'{} ->
	  e_msg_ResponseAfterRecv(Msg, TrUserData);
      #'Reply'{} -> e_msg_Reply(Msg, TrUserData);
      #'Buy'{} -> e_msg_Buy(Msg, TrUserData);
      #'General'{} -> e_msg_General(Msg, TrUserData)
    end.



e_msg_Sell(Msg, TrUserData) ->
    e_msg_Sell(Msg, <<>>, TrUserData).


e_msg_Sell(#'Sell'{companySell = F1, qttSell = F2,
		   priceMin = F3},
	   Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case is_empty_string(TrF1) of
		    true -> Bin;
		    false -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    B2 = if F2 == undefined -> B1;
	    true ->
		begin
		  TrF2 = id(F2, TrUserData),
		  if TrF2 =:= 0 -> B1;
		     true -> e_type_int32(TrF2, <<B1/binary, 16>>)
		  end
		end
	 end,
    if F3 == undefined -> B2;
       true ->
	   begin
	     TrF3 = id(F3, TrUserData),
	     if TrF3 =:= 0.0 -> B2;
		true -> e_type_float(TrF3, <<B2/binary, 29>>)
	     end
	   end
    end.

e_msg_UpdateReply(Msg, TrUserData) ->
    e_msg_UpdateReply(Msg, <<>>, TrUserData).


e_msg_UpdateReply(#'UpdateReply'{result = F1,
				 company = F2, quantity = F3, price = F4},
		  Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case is_empty_string(TrF1) of
		    true -> Bin;
		    false -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    B2 = if F2 == undefined -> B1;
	    true ->
		begin
		  TrF2 = id(F2, TrUserData),
		  case is_empty_string(TrF2) of
		    true -> B1;
		    false -> e_type_string(TrF2, <<B1/binary, 18>>)
		  end
		end
	 end,
    B3 = if F3 == undefined -> B2;
	    true ->
		begin
		  TrF3 = id(F3, TrUserData),
		  if TrF3 =:= 0 -> B2;
		     true -> e_type_int32(TrF3, <<B2/binary, 24>>)
		  end
		end
	 end,
    if F4 == undefined -> B3;
       true ->
	   begin
	     TrF4 = id(F4, TrUserData),
	     if TrF4 =:= 0.0 -> B3;
		true -> e_type_float(TrF4, <<B3/binary, 37>>)
	     end
	   end
    end.

e_msg_ResponseAfterRecv(Msg, TrUserData) ->
    e_msg_ResponseAfterRecv(Msg, <<>>, TrUserData).


e_msg_ResponseAfterRecv(#'ResponseAfterRecv'{rep = F1},
			Bin, TrUserData) ->
    if F1 == undefined -> Bin;
       true ->
	   begin
	     TrF1 = id(F1, TrUserData),
	     case is_empty_string(TrF1) of
	       true -> Bin;
	       false -> e_type_string(TrF1, <<Bin/binary, 10>>)
	     end
	   end
    end.

e_msg_Reply(Msg, TrUserData) ->
    e_msg_Reply(Msg, <<>>, TrUserData).


e_msg_Reply(#'Reply'{reply = F1}, Bin, TrUserData) ->
    case F1 of
      undefined -> Bin;
      {rAR, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    e_mfield_Reply_rAR(TrOF1, <<Bin/binary, 10>>,
			       TrUserData)
	  end;
      {uR, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    e_mfield_Reply_uR(TrOF1, <<Bin/binary, 18>>, TrUserData)
	  end
    end.

e_msg_Buy(Msg, TrUserData) ->
    e_msg_Buy(Msg, <<>>, TrUserData).


e_msg_Buy(#'Buy'{companyBuy = F1, qttBuy = F2,
		 priceMax = F3},
	  Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case is_empty_string(TrF1) of
		    true -> Bin;
		    false -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    B2 = if F2 == undefined -> B1;
	    true ->
		begin
		  TrF2 = id(F2, TrUserData),
		  if TrF2 =:= 0 -> B1;
		     true -> e_type_int32(TrF2, <<B1/binary, 16>>)
		  end
		end
	 end,
    if F3 == undefined -> B2;
       true ->
	   begin
	     TrF3 = id(F3, TrUserData),
	     if TrF3 =:= 0.0 -> B2;
		true -> e_type_float(TrF3, <<B2/binary, 29>>)
	     end
	   end
    end.

e_msg_General(Msg, TrUserData) ->
    e_msg_General(Msg, <<>>, TrUserData).


e_msg_General(#'General'{general = F1}, Bin,
	      TrUserData) ->
    case F1 of
      undefined -> Bin;
      {buy, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    e_mfield_General_buy(TrOF1, <<Bin/binary, 10>>,
				 TrUserData)
	  end;
      {sell, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    e_mfield_General_sell(TrOF1, <<Bin/binary, 18>>,
				  TrUserData)
	  end
    end.

e_mfield_Reply_rAR(Msg, Bin, TrUserData) ->
    SubBin = e_msg_ResponseAfterRecv(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_mfield_Reply_uR(Msg, Bin, TrUserData) ->
    SubBin = e_msg_UpdateReply(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_mfield_General_buy(Msg, Bin, TrUserData) ->
    SubBin = e_msg_Buy(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_mfield_General_sell(Msg, Bin, TrUserData) ->
    SubBin = e_msg_Sell(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_type_int32(Value, Bin)
    when 0 =< Value, Value =< 127 ->
    <<Bin/binary, Value>>;
e_type_int32(Value, Bin) ->
    <<N:64/unsigned-native>> = <<Value:64/signed-native>>,
    e_varint(N, Bin).

e_type_string(S, Bin) ->
    Utf8 = unicode:characters_to_binary(S),
    Bin2 = e_varint(byte_size(Utf8), Bin),
    <<Bin2/binary, Utf8/binary>>.

e_type_float(V, Bin) when is_number(V) ->
    <<Bin/binary, V:32/little-float>>;
e_type_float(infinity, Bin) ->
    <<Bin/binary, 0:16, 128, 127>>;
e_type_float('-infinity', Bin) ->
    <<Bin/binary, 0:16, 128, 255>>;
e_type_float(nan, Bin) ->
    <<Bin/binary, 0:16, 192, 127>>.

e_varint(N, Bin) when N =< 127 -> <<Bin/binary, N>>;
e_varint(N, Bin) ->
    Bin2 = <<Bin/binary, (N band 127 bor 128)>>,
    e_varint(N bsr 7, Bin2).

is_empty_string("") -> true;
is_empty_string(<<>>) -> true;
is_empty_string(L) when is_list(L) ->
    not string_has_chars(L);
is_empty_string(B) when is_binary(B) -> false.

string_has_chars([C | _]) when is_integer(C) -> true;
string_has_chars([H | T]) ->
    case string_has_chars(H) of
      true -> true;
      false -> string_has_chars(T)
    end;
string_has_chars(B)
    when is_binary(B), byte_size(B) =/= 0 ->
    true;
string_has_chars(C) when is_integer(C) -> true;
string_has_chars(<<>>) -> false;
string_has_chars([]) -> false.


decode_msg(Bin, MsgName) when is_binary(Bin) ->
    decode_msg(Bin, MsgName, []).

decode_msg(Bin, MsgName, Opts) when is_binary(Bin) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case MsgName of
      'Sell' ->
	  try d_msg_Sell(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'Sell', {Class, Reason, StackTrace}}}})
	  end;
      'UpdateReply' ->
	  try d_msg_UpdateReply(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'UpdateReply', {Class, Reason, StackTrace}}}})
	  end;
      'ResponseAfterRecv' ->
	  try d_msg_ResponseAfterRecv(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'ResponseAfterRecv',
			 {Class, Reason, StackTrace}}}})
	  end;
      'Reply' ->
	  try d_msg_Reply(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'Reply', {Class, Reason, StackTrace}}}})
	  end;
      'Buy' ->
	  try d_msg_Buy(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'Buy', {Class, Reason, StackTrace}}}})
	  end;
      'General' ->
	  try d_msg_General(Bin, TrUserData) catch
	    Class:Reason ->
		StackTrace = erlang:get_stacktrace(),
		error({gpb_error,
		       {decoding_failure,
			{Bin, 'General', {Class, Reason, StackTrace}}}})
	  end
    end.



d_msg_Sell(Bin, TrUserData) ->
    dfp_read_field_def_Sell(Bin, 0, 0, id([], TrUserData),
			    id(0, TrUserData), id(0.0, TrUserData), TrUserData).

dfp_read_field_def_Sell(<<10, Rest/binary>>, Z1, Z2,
			F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Sell_companySell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			     TrUserData);
dfp_read_field_def_Sell(<<16, Rest/binary>>, Z1, Z2,
			F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Sell_qttSell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			 TrUserData);
dfp_read_field_def_Sell(<<29, Rest/binary>>, Z1, Z2,
			F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Sell_priceMin(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			  TrUserData);
dfp_read_field_def_Sell(<<>>, 0, 0, F@_1, F@_2, F@_3,
			_) ->
    #'Sell'{companySell = F@_1, qttSell = F@_2,
	    priceMin = F@_3};
dfp_read_field_def_Sell(Other, Z1, Z2, F@_1, F@_2, F@_3,
			TrUserData) ->
    dg_read_field_def_Sell(Other, Z1, Z2, F@_1, F@_2, F@_3,
			   TrUserData).

dg_read_field_def_Sell(<<1:1, X:7, Rest/binary>>, N,
		       Acc, F@_1, F@_2, F@_3, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_Sell(Rest, N + 7, X bsl N + Acc, F@_1,
			   F@_2, F@_3, TrUserData);
dg_read_field_def_Sell(<<0:1, X:7, Rest/binary>>, N,
		       Acc, F@_1, F@_2, F@_3, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  d_field_Sell_companySell(Rest, 0, 0, F@_1, F@_2, F@_3,
				   TrUserData);
      16 ->
	  d_field_Sell_qttSell(Rest, 0, 0, F@_1, F@_2, F@_3,
			       TrUserData);
      29 ->
	  d_field_Sell_priceMin(Rest, 0, 0, F@_1, F@_2, F@_3,
				TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_Sell(Rest, 0, 0, F@_1, F@_2, F@_3,
				 TrUserData);
	    1 ->
		skip_64_Sell(Rest, 0, 0, F@_1, F@_2, F@_3, TrUserData);
	    2 ->
		skip_length_delimited_Sell(Rest, 0, 0, F@_1, F@_2, F@_3,
					   TrUserData);
	    3 ->
		skip_group_Sell(Rest, Key bsr 3, 0, F@_1, F@_2, F@_3,
				TrUserData);
	    5 ->
		skip_32_Sell(Rest, 0, 0, F@_1, F@_2, F@_3, TrUserData)
	  end
    end;
dg_read_field_def_Sell(<<>>, 0, 0, F@_1, F@_2, F@_3,
		       _) ->
    #'Sell'{companySell = F@_1, qttSell = F@_2,
	    priceMin = F@_3}.

d_field_Sell_companySell(<<1:1, X:7, Rest/binary>>, N,
			 Acc, F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    d_field_Sell_companySell(Rest, N + 7, X bsl N + Acc,
			     F@_1, F@_2, F@_3, TrUserData);
d_field_Sell_companySell(<<0:1, X:7, Rest/binary>>, N,
			 Acc, _, F@_2, F@_3, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Utf8:Len/binary, Rest2/binary>> = Rest,
			   {unicode:characters_to_list(Utf8, unicode), Rest2}
			 end,
    dfp_read_field_def_Sell(RestF, 0, 0, NewFValue, F@_2,
			    F@_3, TrUserData).

d_field_Sell_qttSell(<<1:1, X:7, Rest/binary>>, N, Acc,
		     F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    d_field_Sell_qttSell(Rest, N + 7, X bsl N + Acc, F@_1,
			 F@_2, F@_3, TrUserData);
d_field_Sell_qttSell(<<0:1, X:7, Rest/binary>>, N, Acc,
		     F@_1, _, F@_3, TrUserData) ->
    {NewFValue, RestF} = {begin
			    <<Res:32/signed-native>> = <<(X bsl N +
							    Acc):32/unsigned-native>>,
			    Res
			  end,
			  Rest},
    dfp_read_field_def_Sell(RestF, 0, 0, F@_1, NewFValue,
			    F@_3, TrUserData).

d_field_Sell_priceMin(<<0:16, 128, 127, Rest/binary>>,
		      Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2,
			    infinity, TrUserData);
d_field_Sell_priceMin(<<0:16, 128, 255, Rest/binary>>,
		      Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2,
			    '-infinity', TrUserData);
d_field_Sell_priceMin(<<_:16, 1:1, _:7, _:1, 127:7,
			Rest/binary>>,
		      Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2, nan,
			    TrUserData);
d_field_Sell_priceMin(<<Value:32/little-float,
			Rest/binary>>,
		      Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2, Value,
			    TrUserData).

skip_varint_Sell(<<1:1, _:7, Rest/binary>>, Z1, Z2,
		 F@_1, F@_2, F@_3, TrUserData) ->
    skip_varint_Sell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
		     TrUserData);
skip_varint_Sell(<<0:1, _:7, Rest/binary>>, Z1, Z2,
		 F@_1, F@_2, F@_3, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			    TrUserData).

skip_length_delimited_Sell(<<1:1, X:7, Rest/binary>>, N,
			   Acc, F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    skip_length_delimited_Sell(Rest, N + 7, X bsl N + Acc,
			       F@_1, F@_2, F@_3, TrUserData);
skip_length_delimited_Sell(<<0:1, X:7, Rest/binary>>, N,
			   Acc, F@_1, F@_2, F@_3, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_Sell(Rest2, 0, 0, F@_1, F@_2, F@_3,
			    TrUserData).

skip_group_Sell(Bin, FNum, Z2, F@_1, F@_2, F@_3,
		TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_Sell(Rest, 0, Z2, F@_1, F@_2, F@_3,
			    TrUserData).

skip_32_Sell(<<_:32, Rest/binary>>, Z1, Z2, F@_1, F@_2,
	     F@_3, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			    TrUserData).

skip_64_Sell(<<_:64, Rest/binary>>, Z1, Z2, F@_1, F@_2,
	     F@_3, TrUserData) ->
    dfp_read_field_def_Sell(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			    TrUserData).

d_msg_UpdateReply(Bin, TrUserData) ->
    dfp_read_field_def_UpdateReply(Bin, 0, 0,
				   id([], TrUserData), id([], TrUserData),
				   id(0, TrUserData), id(0.0, TrUserData),
				   TrUserData).

dfp_read_field_def_UpdateReply(<<10, Rest/binary>>, Z1,
			       Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    d_field_UpdateReply_result(Rest, Z1, Z2, F@_1, F@_2,
			       F@_3, F@_4, TrUserData);
dfp_read_field_def_UpdateReply(<<18, Rest/binary>>, Z1,
			       Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    d_field_UpdateReply_company(Rest, Z1, Z2, F@_1, F@_2,
				F@_3, F@_4, TrUserData);
dfp_read_field_def_UpdateReply(<<24, Rest/binary>>, Z1,
			       Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    d_field_UpdateReply_quantity(Rest, Z1, Z2, F@_1, F@_2,
				 F@_3, F@_4, TrUserData);
dfp_read_field_def_UpdateReply(<<37, Rest/binary>>, Z1,
			       Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    d_field_UpdateReply_price(Rest, Z1, Z2, F@_1, F@_2,
			      F@_3, F@_4, TrUserData);
dfp_read_field_def_UpdateReply(<<>>, 0, 0, F@_1, F@_2,
			       F@_3, F@_4, _) ->
    #'UpdateReply'{result = F@_1, company = F@_2,
		   quantity = F@_3, price = F@_4};
dfp_read_field_def_UpdateReply(Other, Z1, Z2, F@_1,
			       F@_2, F@_3, F@_4, TrUserData) ->
    dg_read_field_def_UpdateReply(Other, Z1, Z2, F@_1, F@_2,
				  F@_3, F@_4, TrUserData).

dg_read_field_def_UpdateReply(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_UpdateReply(Rest, N + 7,
				  X bsl N + Acc, F@_1, F@_2, F@_3, F@_4,
				  TrUserData);
dg_read_field_def_UpdateReply(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  d_field_UpdateReply_result(Rest, 0, 0, F@_1, F@_2, F@_3,
				     F@_4, TrUserData);
      18 ->
	  d_field_UpdateReply_company(Rest, 0, 0, F@_1, F@_2,
				      F@_3, F@_4, TrUserData);
      24 ->
	  d_field_UpdateReply_quantity(Rest, 0, 0, F@_1, F@_2,
				       F@_3, F@_4, TrUserData);
      37 ->
	  d_field_UpdateReply_price(Rest, 0, 0, F@_1, F@_2, F@_3,
				    F@_4, TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_UpdateReply(Rest, 0, 0, F@_1, F@_2, F@_3,
					F@_4, TrUserData);
	    1 ->
		skip_64_UpdateReply(Rest, 0, 0, F@_1, F@_2, F@_3, F@_4,
				    TrUserData);
	    2 ->
		skip_length_delimited_UpdateReply(Rest, 0, 0, F@_1,
						  F@_2, F@_3, F@_4, TrUserData);
	    3 ->
		skip_group_UpdateReply(Rest, Key bsr 3, 0, F@_1, F@_2,
				       F@_3, F@_4, TrUserData);
	    5 ->
		skip_32_UpdateReply(Rest, 0, 0, F@_1, F@_2, F@_3, F@_4,
				    TrUserData)
	  end
    end;
dg_read_field_def_UpdateReply(<<>>, 0, 0, F@_1, F@_2,
			      F@_3, F@_4, _) ->
    #'UpdateReply'{result = F@_1, company = F@_2,
		   quantity = F@_3, price = F@_4}.

d_field_UpdateReply_result(<<1:1, X:7, Rest/binary>>, N,
			   Acc, F@_1, F@_2, F@_3, F@_4, TrUserData)
    when N < 57 ->
    d_field_UpdateReply_result(Rest, N + 7, X bsl N + Acc,
			       F@_1, F@_2, F@_3, F@_4, TrUserData);
d_field_UpdateReply_result(<<0:1, X:7, Rest/binary>>, N,
			   Acc, _, F@_2, F@_3, F@_4, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Utf8:Len/binary, Rest2/binary>> = Rest,
			   {unicode:characters_to_list(Utf8, unicode), Rest2}
			 end,
    dfp_read_field_def_UpdateReply(RestF, 0, 0, NewFValue,
				   F@_2, F@_3, F@_4, TrUserData).

d_field_UpdateReply_company(<<1:1, X:7, Rest/binary>>,
			    N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData)
    when N < 57 ->
    d_field_UpdateReply_company(Rest, N + 7, X bsl N + Acc,
				F@_1, F@_2, F@_3, F@_4, TrUserData);
d_field_UpdateReply_company(<<0:1, X:7, Rest/binary>>,
			    N, Acc, F@_1, _, F@_3, F@_4, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Utf8:Len/binary, Rest2/binary>> = Rest,
			   {unicode:characters_to_list(Utf8, unicode), Rest2}
			 end,
    dfp_read_field_def_UpdateReply(RestF, 0, 0, F@_1,
				   NewFValue, F@_3, F@_4, TrUserData).

d_field_UpdateReply_quantity(<<1:1, X:7, Rest/binary>>,
			     N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData)
    when N < 57 ->
    d_field_UpdateReply_quantity(Rest, N + 7, X bsl N + Acc,
				 F@_1, F@_2, F@_3, F@_4, TrUserData);
d_field_UpdateReply_quantity(<<0:1, X:7, Rest/binary>>,
			     N, Acc, F@_1, F@_2, _, F@_4, TrUserData) ->
    {NewFValue, RestF} = {begin
			    <<Res:32/signed-native>> = <<(X bsl N +
							    Acc):32/unsigned-native>>,
			    Res
			  end,
			  Rest},
    dfp_read_field_def_UpdateReply(RestF, 0, 0, F@_1, F@_2,
				   NewFValue, F@_4, TrUserData).

d_field_UpdateReply_price(<<0:16, 128, 127,
			    Rest/binary>>,
			  Z1, Z2, F@_1, F@_2, F@_3, _, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, infinity, TrUserData);
d_field_UpdateReply_price(<<0:16, 128, 255,
			    Rest/binary>>,
			  Z1, Z2, F@_1, F@_2, F@_3, _, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, '-infinity', TrUserData);
d_field_UpdateReply_price(<<_:16, 1:1, _:7, _:1, 127:7,
			    Rest/binary>>,
			  Z1, Z2, F@_1, F@_2, F@_3, _, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, nan, TrUserData);
d_field_UpdateReply_price(<<Value:32/little-float,
			    Rest/binary>>,
			  Z1, Z2, F@_1, F@_2, F@_3, _, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, Value, TrUserData).

skip_varint_UpdateReply(<<1:1, _:7, Rest/binary>>, Z1,
			Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    skip_varint_UpdateReply(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			    F@_4, TrUserData);
skip_varint_UpdateReply(<<0:1, _:7, Rest/binary>>, Z1,
			Z2, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, F@_4, TrUserData).

skip_length_delimited_UpdateReply(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData)
    when N < 57 ->
    skip_length_delimited_UpdateReply(Rest, N + 7,
				      X bsl N + Acc, F@_1, F@_2, F@_3, F@_4,
				      TrUserData);
skip_length_delimited_UpdateReply(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F@_1, F@_2, F@_3, F@_4, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_UpdateReply(Rest2, 0, 0, F@_1, F@_2,
				   F@_3, F@_4, TrUserData).

skip_group_UpdateReply(Bin, FNum, Z2, F@_1, F@_2, F@_3,
		       F@_4, TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_UpdateReply(Rest, 0, Z2, F@_1, F@_2,
				   F@_3, F@_4, TrUserData).

skip_32_UpdateReply(<<_:32, Rest/binary>>, Z1, Z2, F@_1,
		    F@_2, F@_3, F@_4, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, F@_4, TrUserData).

skip_64_UpdateReply(<<_:64, Rest/binary>>, Z1, Z2, F@_1,
		    F@_2, F@_3, F@_4, TrUserData) ->
    dfp_read_field_def_UpdateReply(Rest, Z1, Z2, F@_1, F@_2,
				   F@_3, F@_4, TrUserData).

d_msg_ResponseAfterRecv(Bin, TrUserData) ->
    dfp_read_field_def_ResponseAfterRecv(Bin, 0, 0,
					 id([], TrUserData), TrUserData).

dfp_read_field_def_ResponseAfterRecv(<<10,
				       Rest/binary>>,
				     Z1, Z2, F@_1, TrUserData) ->
    d_field_ResponseAfterRecv_rep(Rest, Z1, Z2, F@_1,
				  TrUserData);
dfp_read_field_def_ResponseAfterRecv(<<>>, 0, 0, F@_1,
				     _) ->
    #'ResponseAfterRecv'{rep = F@_1};
dfp_read_field_def_ResponseAfterRecv(Other, Z1, Z2,
				     F@_1, TrUserData) ->
    dg_read_field_def_ResponseAfterRecv(Other, Z1, Z2, F@_1,
					TrUserData).

dg_read_field_def_ResponseAfterRecv(<<1:1, X:7,
				      Rest/binary>>,
				    N, Acc, F@_1, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_ResponseAfterRecv(Rest, N + 7,
					X bsl N + Acc, F@_1, TrUserData);
dg_read_field_def_ResponseAfterRecv(<<0:1, X:7,
				      Rest/binary>>,
				    N, Acc, F@_1, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  d_field_ResponseAfterRecv_rep(Rest, 0, 0, F@_1,
					TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_ResponseAfterRecv(Rest, 0, 0, F@_1,
					      TrUserData);
	    1 ->
		skip_64_ResponseAfterRecv(Rest, 0, 0, F@_1, TrUserData);
	    2 ->
		skip_length_delimited_ResponseAfterRecv(Rest, 0, 0,
							F@_1, TrUserData);
	    3 ->
		skip_group_ResponseAfterRecv(Rest, Key bsr 3, 0, F@_1,
					     TrUserData);
	    5 ->
		skip_32_ResponseAfterRecv(Rest, 0, 0, F@_1, TrUserData)
	  end
    end;
dg_read_field_def_ResponseAfterRecv(<<>>, 0, 0, F@_1,
				    _) ->
    #'ResponseAfterRecv'{rep = F@_1}.

d_field_ResponseAfterRecv_rep(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F@_1, TrUserData)
    when N < 57 ->
    d_field_ResponseAfterRecv_rep(Rest, N + 7,
				  X bsl N + Acc, F@_1, TrUserData);
d_field_ResponseAfterRecv_rep(<<0:1, X:7, Rest/binary>>,
			      N, Acc, _, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Utf8:Len/binary, Rest2/binary>> = Rest,
			   {unicode:characters_to_list(Utf8, unicode), Rest2}
			 end,
    dfp_read_field_def_ResponseAfterRecv(RestF, 0, 0,
					 NewFValue, TrUserData).

skip_varint_ResponseAfterRecv(<<1:1, _:7, Rest/binary>>,
			      Z1, Z2, F@_1, TrUserData) ->
    skip_varint_ResponseAfterRecv(Rest, Z1, Z2, F@_1,
				  TrUserData);
skip_varint_ResponseAfterRecv(<<0:1, _:7, Rest/binary>>,
			      Z1, Z2, F@_1, TrUserData) ->
    dfp_read_field_def_ResponseAfterRecv(Rest, Z1, Z2, F@_1,
					 TrUserData).

skip_length_delimited_ResponseAfterRecv(<<1:1, X:7,
					  Rest/binary>>,
					N, Acc, F@_1, TrUserData)
    when N < 57 ->
    skip_length_delimited_ResponseAfterRecv(Rest, N + 7,
					    X bsl N + Acc, F@_1, TrUserData);
skip_length_delimited_ResponseAfterRecv(<<0:1, X:7,
					  Rest/binary>>,
					N, Acc, F@_1, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_ResponseAfterRecv(Rest2, 0, 0, F@_1,
					 TrUserData).

skip_group_ResponseAfterRecv(Bin, FNum, Z2, F@_1,
			     TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_ResponseAfterRecv(Rest, 0, Z2, F@_1,
					 TrUserData).

skip_32_ResponseAfterRecv(<<_:32, Rest/binary>>, Z1, Z2,
			  F@_1, TrUserData) ->
    dfp_read_field_def_ResponseAfterRecv(Rest, Z1, Z2, F@_1,
					 TrUserData).

skip_64_ResponseAfterRecv(<<_:64, Rest/binary>>, Z1, Z2,
			  F@_1, TrUserData) ->
    dfp_read_field_def_ResponseAfterRecv(Rest, Z1, Z2, F@_1,
					 TrUserData).

d_msg_Reply(Bin, TrUserData) ->
    dfp_read_field_def_Reply(Bin, 0, 0,
			     id(undefined, TrUserData), TrUserData).

dfp_read_field_def_Reply(<<10, Rest/binary>>, Z1, Z2,
			 F@_1, TrUserData) ->
    d_field_Reply_rAR(Rest, Z1, Z2, F@_1, TrUserData);
dfp_read_field_def_Reply(<<18, Rest/binary>>, Z1, Z2,
			 F@_1, TrUserData) ->
    d_field_Reply_uR(Rest, Z1, Z2, F@_1, TrUserData);
dfp_read_field_def_Reply(<<>>, 0, 0, F@_1, _) ->
    #'Reply'{reply = F@_1};
dfp_read_field_def_Reply(Other, Z1, Z2, F@_1,
			 TrUserData) ->
    dg_read_field_def_Reply(Other, Z1, Z2, F@_1,
			    TrUserData).

dg_read_field_def_Reply(<<1:1, X:7, Rest/binary>>, N,
			Acc, F@_1, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_Reply(Rest, N + 7, X bsl N + Acc,
			    F@_1, TrUserData);
dg_read_field_def_Reply(<<0:1, X:7, Rest/binary>>, N,
			Acc, F@_1, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 -> d_field_Reply_rAR(Rest, 0, 0, F@_1, TrUserData);
      18 -> d_field_Reply_uR(Rest, 0, 0, F@_1, TrUserData);
      _ ->
	  case Key band 7 of
	    0 -> skip_varint_Reply(Rest, 0, 0, F@_1, TrUserData);
	    1 -> skip_64_Reply(Rest, 0, 0, F@_1, TrUserData);
	    2 ->
		skip_length_delimited_Reply(Rest, 0, 0, F@_1,
					    TrUserData);
	    3 ->
		skip_group_Reply(Rest, Key bsr 3, 0, F@_1, TrUserData);
	    5 -> skip_32_Reply(Rest, 0, 0, F@_1, TrUserData)
	  end
    end;
dg_read_field_def_Reply(<<>>, 0, 0, F@_1, _) ->
    #'Reply'{reply = F@_1}.

d_field_Reply_rAR(<<1:1, X:7, Rest/binary>>, N, Acc,
		  F@_1, TrUserData)
    when N < 57 ->
    d_field_Reply_rAR(Rest, N + 7, X bsl N + Acc, F@_1,
		      TrUserData);
d_field_Reply_rAR(<<0:1, X:7, Rest/binary>>, N, Acc,
		  Prev, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Bs:Len/binary, Rest2/binary>> = Rest,
			   {id(d_msg_ResponseAfterRecv(Bs, TrUserData),
			       TrUserData),
			    Rest2}
			 end,
    dfp_read_field_def_Reply(RestF, 0, 0,
			     case Prev of
			       undefined -> {rAR, NewFValue};
			       {rAR, MVPrev} ->
				   {rAR,
				    merge_msg_ResponseAfterRecv(MVPrev,
								NewFValue,
								TrUserData)};
			       _ -> {rAR, NewFValue}
			     end,
			     TrUserData).

d_field_Reply_uR(<<1:1, X:7, Rest/binary>>, N, Acc,
		 F@_1, TrUserData)
    when N < 57 ->
    d_field_Reply_uR(Rest, N + 7, X bsl N + Acc, F@_1,
		     TrUserData);
d_field_Reply_uR(<<0:1, X:7, Rest/binary>>, N, Acc,
		 Prev, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Bs:Len/binary, Rest2/binary>> = Rest,
			   {id(d_msg_UpdateReply(Bs, TrUserData), TrUserData),
			    Rest2}
			 end,
    dfp_read_field_def_Reply(RestF, 0, 0,
			     case Prev of
			       undefined -> {uR, NewFValue};
			       {uR, MVPrev} ->
				   {uR,
				    merge_msg_UpdateReply(MVPrev, NewFValue,
							  TrUserData)};
			       _ -> {uR, NewFValue}
			     end,
			     TrUserData).

skip_varint_Reply(<<1:1, _:7, Rest/binary>>, Z1, Z2,
		  F@_1, TrUserData) ->
    skip_varint_Reply(Rest, Z1, Z2, F@_1, TrUserData);
skip_varint_Reply(<<0:1, _:7, Rest/binary>>, Z1, Z2,
		  F@_1, TrUserData) ->
    dfp_read_field_def_Reply(Rest, Z1, Z2, F@_1,
			     TrUserData).

skip_length_delimited_Reply(<<1:1, X:7, Rest/binary>>,
			    N, Acc, F@_1, TrUserData)
    when N < 57 ->
    skip_length_delimited_Reply(Rest, N + 7, X bsl N + Acc,
				F@_1, TrUserData);
skip_length_delimited_Reply(<<0:1, X:7, Rest/binary>>,
			    N, Acc, F@_1, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_Reply(Rest2, 0, 0, F@_1, TrUserData).

skip_group_Reply(Bin, FNum, Z2, F@_1, TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_Reply(Rest, 0, Z2, F@_1, TrUserData).

skip_32_Reply(<<_:32, Rest/binary>>, Z1, Z2, F@_1,
	      TrUserData) ->
    dfp_read_field_def_Reply(Rest, Z1, Z2, F@_1,
			     TrUserData).

skip_64_Reply(<<_:64, Rest/binary>>, Z1, Z2, F@_1,
	      TrUserData) ->
    dfp_read_field_def_Reply(Rest, Z1, Z2, F@_1,
			     TrUserData).

d_msg_Buy(Bin, TrUserData) ->
    dfp_read_field_def_Buy(Bin, 0, 0, id([], TrUserData),
			   id(0, TrUserData), id(0.0, TrUserData), TrUserData).

dfp_read_field_def_Buy(<<10, Rest/binary>>, Z1, Z2,
		       F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Buy_companyBuy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			   TrUserData);
dfp_read_field_def_Buy(<<16, Rest/binary>>, Z1, Z2,
		       F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Buy_qttBuy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
		       TrUserData);
dfp_read_field_def_Buy(<<29, Rest/binary>>, Z1, Z2,
		       F@_1, F@_2, F@_3, TrUserData) ->
    d_field_Buy_priceMax(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			 TrUserData);
dfp_read_field_def_Buy(<<>>, 0, 0, F@_1, F@_2, F@_3,
		       _) ->
    #'Buy'{companyBuy = F@_1, qttBuy = F@_2,
	   priceMax = F@_3};
dfp_read_field_def_Buy(Other, Z1, Z2, F@_1, F@_2, F@_3,
		       TrUserData) ->
    dg_read_field_def_Buy(Other, Z1, Z2, F@_1, F@_2, F@_3,
			  TrUserData).

dg_read_field_def_Buy(<<1:1, X:7, Rest/binary>>, N, Acc,
		      F@_1, F@_2, F@_3, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_Buy(Rest, N + 7, X bsl N + Acc, F@_1,
			  F@_2, F@_3, TrUserData);
dg_read_field_def_Buy(<<0:1, X:7, Rest/binary>>, N, Acc,
		      F@_1, F@_2, F@_3, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  d_field_Buy_companyBuy(Rest, 0, 0, F@_1, F@_2, F@_3,
				 TrUserData);
      16 ->
	  d_field_Buy_qttBuy(Rest, 0, 0, F@_1, F@_2, F@_3,
			     TrUserData);
      29 ->
	  d_field_Buy_priceMax(Rest, 0, 0, F@_1, F@_2, F@_3,
			       TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_Buy(Rest, 0, 0, F@_1, F@_2, F@_3,
				TrUserData);
	    1 ->
		skip_64_Buy(Rest, 0, 0, F@_1, F@_2, F@_3, TrUserData);
	    2 ->
		skip_length_delimited_Buy(Rest, 0, 0, F@_1, F@_2, F@_3,
					  TrUserData);
	    3 ->
		skip_group_Buy(Rest, Key bsr 3, 0, F@_1, F@_2, F@_3,
			       TrUserData);
	    5 ->
		skip_32_Buy(Rest, 0, 0, F@_1, F@_2, F@_3, TrUserData)
	  end
    end;
dg_read_field_def_Buy(<<>>, 0, 0, F@_1, F@_2, F@_3,
		      _) ->
    #'Buy'{companyBuy = F@_1, qttBuy = F@_2,
	   priceMax = F@_3}.

d_field_Buy_companyBuy(<<1:1, X:7, Rest/binary>>, N,
		       Acc, F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    d_field_Buy_companyBuy(Rest, N + 7, X bsl N + Acc, F@_1,
			   F@_2, F@_3, TrUserData);
d_field_Buy_companyBuy(<<0:1, X:7, Rest/binary>>, N,
		       Acc, _, F@_2, F@_3, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Utf8:Len/binary, Rest2/binary>> = Rest,
			   {unicode:characters_to_list(Utf8, unicode), Rest2}
			 end,
    dfp_read_field_def_Buy(RestF, 0, 0, NewFValue, F@_2,
			   F@_3, TrUserData).

d_field_Buy_qttBuy(<<1:1, X:7, Rest/binary>>, N, Acc,
		   F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    d_field_Buy_qttBuy(Rest, N + 7, X bsl N + Acc, F@_1,
		       F@_2, F@_3, TrUserData);
d_field_Buy_qttBuy(<<0:1, X:7, Rest/binary>>, N, Acc,
		   F@_1, _, F@_3, TrUserData) ->
    {NewFValue, RestF} = {begin
			    <<Res:32/signed-native>> = <<(X bsl N +
							    Acc):32/unsigned-native>>,
			    Res
			  end,
			  Rest},
    dfp_read_field_def_Buy(RestF, 0, 0, F@_1, NewFValue,
			   F@_3, TrUserData).

d_field_Buy_priceMax(<<0:16, 128, 127, Rest/binary>>,
		     Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2,
			   infinity, TrUserData);
d_field_Buy_priceMax(<<0:16, 128, 255, Rest/binary>>,
		     Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2,
			   '-infinity', TrUserData);
d_field_Buy_priceMax(<<_:16, 1:1, _:7, _:1, 127:7,
		       Rest/binary>>,
		     Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2, nan,
			   TrUserData);
d_field_Buy_priceMax(<<Value:32/little-float,
		       Rest/binary>>,
		     Z1, Z2, F@_1, F@_2, _, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2, Value,
			   TrUserData).

skip_varint_Buy(<<1:1, _:7, Rest/binary>>, Z1, Z2, F@_1,
		F@_2, F@_3, TrUserData) ->
    skip_varint_Buy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
		    TrUserData);
skip_varint_Buy(<<0:1, _:7, Rest/binary>>, Z1, Z2, F@_1,
		F@_2, F@_3, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			   TrUserData).

skip_length_delimited_Buy(<<1:1, X:7, Rest/binary>>, N,
			  Acc, F@_1, F@_2, F@_3, TrUserData)
    when N < 57 ->
    skip_length_delimited_Buy(Rest, N + 7, X bsl N + Acc,
			      F@_1, F@_2, F@_3, TrUserData);
skip_length_delimited_Buy(<<0:1, X:7, Rest/binary>>, N,
			  Acc, F@_1, F@_2, F@_3, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_Buy(Rest2, 0, 0, F@_1, F@_2, F@_3,
			   TrUserData).

skip_group_Buy(Bin, FNum, Z2, F@_1, F@_2, F@_3,
	       TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_Buy(Rest, 0, Z2, F@_1, F@_2, F@_3,
			   TrUserData).

skip_32_Buy(<<_:32, Rest/binary>>, Z1, Z2, F@_1, F@_2,
	    F@_3, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			   TrUserData).

skip_64_Buy(<<_:64, Rest/binary>>, Z1, Z2, F@_1, F@_2,
	    F@_3, TrUserData) ->
    dfp_read_field_def_Buy(Rest, Z1, Z2, F@_1, F@_2, F@_3,
			   TrUserData).

d_msg_General(Bin, TrUserData) ->
    dfp_read_field_def_General(Bin, 0, 0,
			       id(undefined, TrUserData), TrUserData).

dfp_read_field_def_General(<<10, Rest/binary>>, Z1, Z2,
			   F@_1, TrUserData) ->
    d_field_General_buy(Rest, Z1, Z2, F@_1, TrUserData);
dfp_read_field_def_General(<<18, Rest/binary>>, Z1, Z2,
			   F@_1, TrUserData) ->
    d_field_General_sell(Rest, Z1, Z2, F@_1, TrUserData);
dfp_read_field_def_General(<<>>, 0, 0, F@_1, _) ->
    #'General'{general = F@_1};
dfp_read_field_def_General(Other, Z1, Z2, F@_1,
			   TrUserData) ->
    dg_read_field_def_General(Other, Z1, Z2, F@_1,
			      TrUserData).

dg_read_field_def_General(<<1:1, X:7, Rest/binary>>, N,
			  Acc, F@_1, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_General(Rest, N + 7, X bsl N + Acc,
			      F@_1, TrUserData);
dg_read_field_def_General(<<0:1, X:7, Rest/binary>>, N,
			  Acc, F@_1, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 -> d_field_General_buy(Rest, 0, 0, F@_1, TrUserData);
      18 ->
	  d_field_General_sell(Rest, 0, 0, F@_1, TrUserData);
      _ ->
	  case Key band 7 of
	    0 -> skip_varint_General(Rest, 0, 0, F@_1, TrUserData);
	    1 -> skip_64_General(Rest, 0, 0, F@_1, TrUserData);
	    2 ->
		skip_length_delimited_General(Rest, 0, 0, F@_1,
					      TrUserData);
	    3 ->
		skip_group_General(Rest, Key bsr 3, 0, F@_1,
				   TrUserData);
	    5 -> skip_32_General(Rest, 0, 0, F@_1, TrUserData)
	  end
    end;
dg_read_field_def_General(<<>>, 0, 0, F@_1, _) ->
    #'General'{general = F@_1}.

d_field_General_buy(<<1:1, X:7, Rest/binary>>, N, Acc,
		    F@_1, TrUserData)
    when N < 57 ->
    d_field_General_buy(Rest, N + 7, X bsl N + Acc, F@_1,
			TrUserData);
d_field_General_buy(<<0:1, X:7, Rest/binary>>, N, Acc,
		    Prev, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Bs:Len/binary, Rest2/binary>> = Rest,
			   {id(d_msg_Buy(Bs, TrUserData), TrUserData), Rest2}
			 end,
    dfp_read_field_def_General(RestF, 0, 0,
			       case Prev of
				 undefined -> {buy, NewFValue};
				 {buy, MVPrev} ->
				     {buy,
				      merge_msg_Buy(MVPrev, NewFValue,
						    TrUserData)};
				 _ -> {buy, NewFValue}
			       end,
			       TrUserData).

d_field_General_sell(<<1:1, X:7, Rest/binary>>, N, Acc,
		     F@_1, TrUserData)
    when N < 57 ->
    d_field_General_sell(Rest, N + 7, X bsl N + Acc, F@_1,
			 TrUserData);
d_field_General_sell(<<0:1, X:7, Rest/binary>>, N, Acc,
		     Prev, TrUserData) ->
    {NewFValue, RestF} = begin
			   Len = X bsl N + Acc,
			   <<Bs:Len/binary, Rest2/binary>> = Rest,
			   {id(d_msg_Sell(Bs, TrUserData), TrUserData), Rest2}
			 end,
    dfp_read_field_def_General(RestF, 0, 0,
			       case Prev of
				 undefined -> {sell, NewFValue};
				 {sell, MVPrev} ->
				     {sell,
				      merge_msg_Sell(MVPrev, NewFValue,
						     TrUserData)};
				 _ -> {sell, NewFValue}
			       end,
			       TrUserData).

skip_varint_General(<<1:1, _:7, Rest/binary>>, Z1, Z2,
		    F@_1, TrUserData) ->
    skip_varint_General(Rest, Z1, Z2, F@_1, TrUserData);
skip_varint_General(<<0:1, _:7, Rest/binary>>, Z1, Z2,
		    F@_1, TrUserData) ->
    dfp_read_field_def_General(Rest, Z1, Z2, F@_1,
			       TrUserData).

skip_length_delimited_General(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F@_1, TrUserData)
    when N < 57 ->
    skip_length_delimited_General(Rest, N + 7,
				  X bsl N + Acc, F@_1, TrUserData);
skip_length_delimited_General(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F@_1, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_General(Rest2, 0, 0, F@_1,
			       TrUserData).

skip_group_General(Bin, FNum, Z2, F@_1, TrUserData) ->
    {_, Rest} = read_group(Bin, FNum),
    dfp_read_field_def_General(Rest, 0, Z2, F@_1,
			       TrUserData).

skip_32_General(<<_:32, Rest/binary>>, Z1, Z2, F@_1,
		TrUserData) ->
    dfp_read_field_def_General(Rest, Z1, Z2, F@_1,
			       TrUserData).

skip_64_General(<<_:64, Rest/binary>>, Z1, Z2, F@_1,
		TrUserData) ->
    dfp_read_field_def_General(Rest, Z1, Z2, F@_1,
			       TrUserData).

read_group(Bin, FieldNum) ->
    {NumBytes, EndTagLen} = read_gr_b(Bin, 0, 0, 0, 0, FieldNum),
    <<Group:NumBytes/binary, _:EndTagLen/binary, Rest/binary>> = Bin,
    {Group, Rest}.

%% Like skipping over fields, but record the total length,
%% Each field is <(FieldNum bsl 3) bor FieldType> ++ <FieldValue>
%% Record the length because varints may be non-optimally encoded.
%%
%% Groups can be nested, but assume the same FieldNum cannot be nested
%% because group field numbers are shared with the rest of the fields
%% numbers. Thus we can search just for an group-end with the same
%% field number.
%%
%% (The only time the same group field number could occur would
%% be in a nested sub message, but then it would be inside a
%% length-delimited entry, which we skip-read by length.)
read_gr_b(<<1:1, X:7, Tl/binary>>, N, Acc, NumBytes, TagLen, FieldNum)
  when N < (32-7) ->
    read_gr_b(Tl, N+7, X bsl N + Acc, NumBytes, TagLen+1, FieldNum);
read_gr_b(<<0:1, X:7, Tl/binary>>, N, Acc, NumBytes, TagLen,
          FieldNum) ->
    Key = X bsl N + Acc,
    TagLen1 = TagLen + 1,
    case {Key bsr 3, Key band 7} of
        {FieldNum, 4} -> % 4 = group_end
            {NumBytes, TagLen1};
        {_, 0} -> % 0 = varint
            read_gr_vi(Tl, 0, NumBytes + TagLen1, FieldNum);
        {_, 1} -> % 1 = bits64
            <<_:64, Tl2/binary>> = Tl,
            read_gr_b(Tl2, 0, 0, NumBytes + TagLen1 + 8, 0, FieldNum);
        {_, 2} -> % 2 = length_delimited
            read_gr_ld(Tl, 0, 0, NumBytes + TagLen1, FieldNum);
        {_, 3} -> % 3 = group_start
            read_gr_b(Tl, 0, 0, NumBytes + TagLen1, 0, FieldNum);
        {_, 4} -> % 4 = group_end
            read_gr_b(Tl, 0, 0, NumBytes + TagLen1, 0, FieldNum);
        {_, 5} -> % 5 = bits32
            <<_:32, Tl2/binary>> = Tl,
            read_gr_b(Tl2, 0, 0, NumBytes + TagLen1 + 4, 0, FieldNum)
    end.

read_gr_vi(<<1:1, _:7, Tl/binary>>, N, NumBytes, FieldNum)
  when N < (64-7) ->
    read_gr_vi(Tl, N+7, NumBytes+1, FieldNum);
read_gr_vi(<<0:1, _:7, Tl/binary>>, _, NumBytes, FieldNum) ->
    read_gr_b(Tl, 0, 0, NumBytes+1, 0, FieldNum).

read_gr_ld(<<1:1, X:7, Tl/binary>>, N, Acc, NumBytes, FieldNum)
  when N < (64-7) ->
    read_gr_ld(Tl, N+7, X bsl N + Acc, NumBytes+1, FieldNum);
read_gr_ld(<<0:1, X:7, Tl/binary>>, N, Acc, NumBytes, FieldNum) ->
    Len = X bsl N + Acc,
    NumBytes1 = NumBytes + 1,
    <<_:Len/binary, Tl2/binary>> = Tl,
    read_gr_b(Tl2, 0, 0, NumBytes1 + Len, 0, FieldNum).

merge_msgs(Prev, New) -> merge_msgs(Prev, New, []).

merge_msgs(Prev, New, Opts)
    when element(1, Prev) =:= element(1, New) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case Prev of
      #'Sell'{} -> merge_msg_Sell(Prev, New, TrUserData);
      #'UpdateReply'{} ->
	  merge_msg_UpdateReply(Prev, New, TrUserData);
      #'ResponseAfterRecv'{} ->
	  merge_msg_ResponseAfterRecv(Prev, New, TrUserData);
      #'Reply'{} -> merge_msg_Reply(Prev, New, TrUserData);
      #'Buy'{} -> merge_msg_Buy(Prev, New, TrUserData);
      #'General'{} -> merge_msg_General(Prev, New, TrUserData)
    end.

merge_msg_Sell(#'Sell'{companySell = PFcompanySell,
		       qttSell = PFqttSell, priceMin = PFpriceMin},
	       #'Sell'{companySell = NFcompanySell,
		       qttSell = NFqttSell, priceMin = NFpriceMin},
	       _) ->
    #'Sell'{companySell =
		if NFcompanySell =:= undefined -> PFcompanySell;
		   true -> NFcompanySell
		end,
	    qttSell =
		if NFqttSell =:= undefined -> PFqttSell;
		   true -> NFqttSell
		end,
	    priceMin =
		if NFpriceMin =:= undefined -> PFpriceMin;
		   true -> NFpriceMin
		end}.

merge_msg_UpdateReply(#'UpdateReply'{result = PFresult,
				     company = PFcompany, quantity = PFquantity,
				     price = PFprice},
		      #'UpdateReply'{result = NFresult, company = NFcompany,
				     quantity = NFquantity, price = NFprice},
		      _) ->
    #'UpdateReply'{result =
		       if NFresult =:= undefined -> PFresult;
			  true -> NFresult
		       end,
		   company =
		       if NFcompany =:= undefined -> PFcompany;
			  true -> NFcompany
		       end,
		   quantity =
		       if NFquantity =:= undefined -> PFquantity;
			  true -> NFquantity
		       end,
		   price =
		       if NFprice =:= undefined -> PFprice;
			  true -> NFprice
		       end}.

merge_msg_ResponseAfterRecv(#'ResponseAfterRecv'{rep =
						     PFrep},
			    #'ResponseAfterRecv'{rep = NFrep}, _) ->
    #'ResponseAfterRecv'{rep =
			     if NFrep =:= undefined -> PFrep;
				true -> NFrep
			     end}.

merge_msg_Reply(#'Reply'{reply = PFreply},
		#'Reply'{reply = NFreply}, TrUserData) ->
    #'Reply'{reply =
		 case {PFreply, NFreply} of
		   {{rAR, OPFreply}, {rAR, ONFreply}} ->
		       {rAR,
			merge_msg_ResponseAfterRecv(OPFreply, ONFreply,
						    TrUserData)};
		   {{uR, OPFreply}, {uR, ONFreply}} ->
		       {uR,
			merge_msg_UpdateReply(OPFreply, ONFreply, TrUserData)};
		   {_, undefined} -> PFreply;
		   _ -> NFreply
		 end}.

merge_msg_Buy(#'Buy'{companyBuy = PFcompanyBuy,
		     qttBuy = PFqttBuy, priceMax = PFpriceMax},
	      #'Buy'{companyBuy = NFcompanyBuy, qttBuy = NFqttBuy,
		     priceMax = NFpriceMax},
	      _) ->
    #'Buy'{companyBuy =
	       if NFcompanyBuy =:= undefined -> PFcompanyBuy;
		  true -> NFcompanyBuy
	       end,
	   qttBuy =
	       if NFqttBuy =:= undefined -> PFqttBuy;
		  true -> NFqttBuy
	       end,
	   priceMax =
	       if NFpriceMax =:= undefined -> PFpriceMax;
		  true -> NFpriceMax
	       end}.

merge_msg_General(#'General'{general = PFgeneral},
		  #'General'{general = NFgeneral}, TrUserData) ->
    #'General'{general =
		   case {PFgeneral, NFgeneral} of
		     {{buy, OPFgeneral}, {buy, ONFgeneral}} ->
			 {buy,
			  merge_msg_Buy(OPFgeneral, ONFgeneral, TrUserData)};
		     {{sell, OPFgeneral}, {sell, ONFgeneral}} ->
			 {sell,
			  merge_msg_Sell(OPFgeneral, ONFgeneral, TrUserData)};
		     {_, undefined} -> PFgeneral;
		     _ -> NFgeneral
		   end}.


verify_msg(Msg) -> verify_msg(Msg, []).

verify_msg(Msg, Opts) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case Msg of
      #'Sell'{} -> v_msg_Sell(Msg, ['Sell'], TrUserData);
      #'UpdateReply'{} ->
	  v_msg_UpdateReply(Msg, ['UpdateReply'], TrUserData);
      #'ResponseAfterRecv'{} ->
	  v_msg_ResponseAfterRecv(Msg, ['ResponseAfterRecv'],
				  TrUserData);
      #'Reply'{} -> v_msg_Reply(Msg, ['Reply'], TrUserData);
      #'Buy'{} -> v_msg_Buy(Msg, ['Buy'], TrUserData);
      #'General'{} ->
	  v_msg_General(Msg, ['General'], TrUserData);
      _ -> mk_type_error(not_a_known_message, Msg, [])
    end.


-dialyzer({nowarn_function,v_msg_Sell/3}).
v_msg_Sell(#'Sell'{companySell = F1, qttSell = F2,
		   priceMin = F3},
	   Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [companySell | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_int32(F2, [qttSell | Path])
    end,
    if F3 == undefined -> ok;
       true -> v_type_float(F3, [priceMin | Path])
    end,
    ok;
v_msg_Sell(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Sell'}, X, Path).

-dialyzer({nowarn_function,v_msg_UpdateReply/3}).
v_msg_UpdateReply(#'UpdateReply'{result = F1,
				 company = F2, quantity = F3, price = F4},
		  Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [result | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_string(F2, [company | Path])
    end,
    if F3 == undefined -> ok;
       true -> v_type_int32(F3, [quantity | Path])
    end,
    if F4 == undefined -> ok;
       true -> v_type_float(F4, [price | Path])
    end,
    ok;
v_msg_UpdateReply(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'UpdateReply'}, X, Path).

-dialyzer({nowarn_function,v_msg_ResponseAfterRecv/3}).
v_msg_ResponseAfterRecv(#'ResponseAfterRecv'{rep = F1},
			Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [rep | Path])
    end,
    ok;
v_msg_ResponseAfterRecv(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'ResponseAfterRecv'}, X,
		  Path).

-dialyzer({nowarn_function,v_msg_Reply/3}).
v_msg_Reply(#'Reply'{reply = F1}, Path, TrUserData) ->
    case F1 of
      undefined -> ok;
      {rAR, OF1} ->
	  v_msg_ResponseAfterRecv(OF1, [rAR, reply | Path],
				  TrUserData);
      {uR, OF1} ->
	  v_msg_UpdateReply(OF1, [uR, reply | Path], TrUserData);
      _ -> mk_type_error(invalid_oneof, F1, [reply | Path])
    end,
    ok.

-dialyzer({nowarn_function,v_msg_Buy/3}).
v_msg_Buy(#'Buy'{companyBuy = F1, qttBuy = F2,
		 priceMax = F3},
	  Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [companyBuy | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_int32(F2, [qttBuy | Path])
    end,
    if F3 == undefined -> ok;
       true -> v_type_float(F3, [priceMax | Path])
    end,
    ok;
v_msg_Buy(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Buy'}, X, Path).

-dialyzer({nowarn_function,v_msg_General/3}).
v_msg_General(#'General'{general = F1}, Path,
	      TrUserData) ->
    case F1 of
      undefined -> ok;
      {buy, OF1} ->
	  v_msg_Buy(OF1, [buy, general | Path], TrUserData);
      {sell, OF1} ->
	  v_msg_Sell(OF1, [sell, general | Path], TrUserData);
      _ -> mk_type_error(invalid_oneof, F1, [general | Path])
    end,
    ok.

-dialyzer({nowarn_function,v_type_int32/2}).
v_type_int32(N, _Path)
    when -2147483648 =< N, N =< 2147483647 ->
    ok;
v_type_int32(N, Path) when is_integer(N) ->
    mk_type_error({value_out_of_range, int32, signed, 32},
		  N, Path);
v_type_int32(X, Path) ->
    mk_type_error({bad_integer, int32, signed, 32}, X,
		  Path).

-dialyzer({nowarn_function,v_type_float/2}).
v_type_float(N, _Path) when is_float(N) -> ok;
v_type_float(N, _Path) when is_integer(N) -> ok;
v_type_float(infinity, _Path) -> ok;
v_type_float('-infinity', _Path) -> ok;
v_type_float(nan, _Path) -> ok;
v_type_float(X, Path) ->
    mk_type_error(bad_float_value, X, Path).

-dialyzer({nowarn_function,v_type_string/2}).
v_type_string(S, Path) when is_list(S); is_binary(S) ->
    try unicode:characters_to_binary(S) of
      B when is_binary(B) -> ok;
      {error, _, _} ->
	  mk_type_error(bad_unicode_string, S, Path)
    catch
      error:badarg ->
	  mk_type_error(bad_unicode_string, S, Path)
    end;
v_type_string(X, Path) ->
    mk_type_error(bad_unicode_string, X, Path).

-spec mk_type_error(_, _, list()) -> no_return().
mk_type_error(Error, ValueSeen, Path) ->
    Path2 = prettify_path(Path),
    erlang:error({gpb_type_error,
		  {Error, [{value, ValueSeen}, {path, Path2}]}}).


prettify_path([]) -> top_level;
prettify_path(PathR) ->
    list_to_atom(lists:append(lists:join(".",
					 lists:map(fun atom_to_list/1,
						   lists:reverse(PathR))))).


-compile({inline,id/2}).
id(X, _TrUserData) -> X.


get_msg_defs() ->
    [{{msg, 'Sell'},
      [#field{name = companySell, fnum = 1, rnum = 2,
	      type = string, occurrence = optional, opts = []},
       #field{name = qttSell, fnum = 2, rnum = 3, type = int32,
	      occurrence = optional, opts = []},
       #field{name = priceMin, fnum = 3, rnum = 4,
	      type = float, occurrence = optional, opts = []}]},
     {{msg, 'UpdateReply'},
      [#field{name = result, fnum = 1, rnum = 2,
	      type = string, occurrence = optional, opts = []},
       #field{name = company, fnum = 2, rnum = 3,
	      type = string, occurrence = optional, opts = []},
       #field{name = quantity, fnum = 3, rnum = 4,
	      type = int32, occurrence = optional, opts = []},
       #field{name = price, fnum = 4, rnum = 5, type = float,
	      occurrence = optional, opts = []}]},
     {{msg, 'ResponseAfterRecv'},
      [#field{name = rep, fnum = 1, rnum = 2, type = string,
	      occurrence = optional, opts = []}]},
     {{msg, 'Reply'},
      [#gpb_oneof{name = reply, rnum = 2,
		  fields =
		      [#field{name = rAR, fnum = 1, rnum = 2,
			      type = {msg, 'ResponseAfterRecv'},
			      occurrence = optional, opts = []},
		       #field{name = uR, fnum = 2, rnum = 2,
			      type = {msg, 'UpdateReply'},
			      occurrence = optional, opts = []}]}]},
     {{msg, 'Buy'},
      [#field{name = companyBuy, fnum = 1, rnum = 2,
	      type = string, occurrence = optional, opts = []},
       #field{name = qttBuy, fnum = 2, rnum = 3, type = int32,
	      occurrence = optional, opts = []},
       #field{name = priceMax, fnum = 3, rnum = 4,
	      type = float, occurrence = optional, opts = []}]},
     {{msg, 'General'},
      [#gpb_oneof{name = general, rnum = 2,
		  fields =
		      [#field{name = buy, fnum = 1, rnum = 2,
			      type = {msg, 'Buy'}, occurrence = optional,
			      opts = []},
		       #field{name = sell, fnum = 2, rnum = 2,
			      type = {msg, 'Sell'}, occurrence = optional,
			      opts = []}]}]}].


get_msg_names() ->
    ['Sell', 'UpdateReply', 'ResponseAfterRecv', 'Reply',
     'Buy', 'General'].


get_group_names() -> [].


get_msg_or_group_names() ->
    ['Sell', 'UpdateReply', 'ResponseAfterRecv', 'Reply',
     'Buy', 'General'].


get_enum_names() -> [].


fetch_msg_def(MsgName) ->
    case find_msg_def(MsgName) of
      Fs when is_list(Fs) -> Fs;
      error -> erlang:error({no_such_msg, MsgName})
    end.


-spec fetch_enum_def(_) -> no_return().
fetch_enum_def(EnumName) ->
    erlang:error({no_such_enum, EnumName}).


find_msg_def('Sell') ->
    [#field{name = companySell, fnum = 1, rnum = 2,
	    type = string, occurrence = optional, opts = []},
     #field{name = qttSell, fnum = 2, rnum = 3, type = int32,
	    occurrence = optional, opts = []},
     #field{name = priceMin, fnum = 3, rnum = 4,
	    type = float, occurrence = optional, opts = []}];
find_msg_def('UpdateReply') ->
    [#field{name = result, fnum = 1, rnum = 2,
	    type = string, occurrence = optional, opts = []},
     #field{name = company, fnum = 2, rnum = 3,
	    type = string, occurrence = optional, opts = []},
     #field{name = quantity, fnum = 3, rnum = 4,
	    type = int32, occurrence = optional, opts = []},
     #field{name = price, fnum = 4, rnum = 5, type = float,
	    occurrence = optional, opts = []}];
find_msg_def('ResponseAfterRecv') ->
    [#field{name = rep, fnum = 1, rnum = 2, type = string,
	    occurrence = optional, opts = []}];
find_msg_def('Reply') ->
    [#gpb_oneof{name = reply, rnum = 2,
		fields =
		    [#field{name = rAR, fnum = 1, rnum = 2,
			    type = {msg, 'ResponseAfterRecv'},
			    occurrence = optional, opts = []},
		     #field{name = uR, fnum = 2, rnum = 2,
			    type = {msg, 'UpdateReply'}, occurrence = optional,
			    opts = []}]}];
find_msg_def('Buy') ->
    [#field{name = companyBuy, fnum = 1, rnum = 2,
	    type = string, occurrence = optional, opts = []},
     #field{name = qttBuy, fnum = 2, rnum = 3, type = int32,
	    occurrence = optional, opts = []},
     #field{name = priceMax, fnum = 3, rnum = 4,
	    type = float, occurrence = optional, opts = []}];
find_msg_def('General') ->
    [#gpb_oneof{name = general, rnum = 2,
		fields =
		    [#field{name = buy, fnum = 1, rnum = 2,
			    type = {msg, 'Buy'}, occurrence = optional,
			    opts = []},
		     #field{name = sell, fnum = 2, rnum = 2,
			    type = {msg, 'Sell'}, occurrence = optional,
			    opts = []}]}];
find_msg_def(_) -> error.


find_enum_def(_) -> error.


-spec enum_symbol_by_value(_, _) -> no_return().
enum_symbol_by_value(E, V) ->
    erlang:error({no_enum_defs, E, V}).


-spec enum_value_by_symbol(_, _) -> no_return().
enum_value_by_symbol(E, V) ->
    erlang:error({no_enum_defs, E, V}).



get_service_names() -> [].


get_service_def(_) -> error.


get_rpc_names(_) -> error.


find_rpc_def(_, _) -> error.



-spec fetch_rpc_def(_, _) -> no_return().
fetch_rpc_def(ServiceName, RpcName) ->
    erlang:error({no_such_rpc, ServiceName, RpcName}).


get_package_name() -> server.



gpb_version_as_string() ->
    "4.1.1".

gpb_version_as_list() ->
    [4,1,1].
